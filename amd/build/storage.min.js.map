{"version":3,"file":"storage.min.js","sources":["../src/storage.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * IndexedDB storage utility for persistent resize plugin\n *\n * @module     tiny_persistentresize/storage\n * @copyright  2025 Andrew Rowatt <A.J.Rowatt@massey.ac.nz>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nconst DB_NAME = 'tiny_persistentresize';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'editorSizes';\n\n/**\n * Open or create the IndexedDB database\n * @returns {Promise<IDBDatabase>}\n */\nconst openDB = () => {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n\n        request.onupgradeneeded = (event) => {\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains(STORE_NAME)) {\n                db.createObjectStore(STORE_NAME);\n            }\n        };\n    });\n};\n\n/**\n * Set a value in IndexedDB\n * @param {string} key - The key to store the value under\n * @param {string} value - The value to store\n * @returns {Promise<void>}\n */\nexport const setItem = async(key, value) => {\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([STORE_NAME], 'readwrite');\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.put(value, key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n\n        transaction.oncomplete = () => db.close();\n    });\n};\n\n/**\n * Get a value from IndexedDB\n * @param {string} key - The key to retrieve the value for\n * @returns {Promise<string|null>}\n */\nexport const getItem = async(key) => {\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([STORE_NAME], 'readonly');\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.get(key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result || null);\n\n        transaction.oncomplete = () => db.close();\n    });\n};\n\n/**\n * Remove a value from IndexedDB\n * @param {string} key - The key to remove\n * @returns {Promise<void>}\n */\nexport const removeItem = async(key) => {\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([STORE_NAME], 'readwrite');\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.delete(key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n\n        transaction.oncomplete = () => db.close();\n    });\n};\n\n/**\n * Get all keys from IndexedDB\n * @returns {Promise<Array<string>>}\n */\nexport const getAllKeys = async() => {\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n        const transaction = db.transaction([STORE_NAME], 'readonly');\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.getAllKeys();\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result || []);\n\n        transaction.oncomplete = () => db.close();\n    });\n};\n"],"names":["STORE_NAME","openDB","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","event","db","target","objectStoreNames","contains","createObjectStore","async","key","value","transaction","objectStore","put","oncomplete","close","get","delete","getAllKeys"],"mappings":";;;;;;;;MAyBMA,WAAa,cAMbC,OAAS,IACJ,IAAIC,SAAQ,CAACC,QAASC,gBACnBC,QAAUC,UAAUC,KAVlB,wBACG,GAWXF,QAAQG,QAAU,IAAMJ,OAAOC,QAAQI,OACvCJ,QAAQK,UAAY,IAAMP,QAAQE,QAAQM,QAE1CN,QAAQO,gBAAmBC,cACjBC,GAAKD,MAAME,OAAOJ,OACnBG,GAAGE,iBAAiBC,SAASjB,aAC9Bc,GAAGI,kBAAkBlB,iCAYdmB,MAAMC,IAAKC,eACxBP,SAAWb,gBACV,IAAIC,SAAQ,CAACC,QAASC,gBACnBkB,YAAcR,GAAGQ,YAAY,CAACtB,YAAa,aAE3CK,QADQiB,YAAYC,YAAYvB,YAChBwB,IAAIH,MAAOD,KAEjCf,QAAQG,QAAU,IAAMJ,OAAOC,QAAQI,OACvCJ,QAAQK,UAAY,IAAMP,UAE1BmB,YAAYG,WAAa,IAAMX,GAAGY,6BASnBP,MAAAA,YACbL,SAAWb,gBACV,IAAIC,SAAQ,CAACC,QAASC,gBACnBkB,YAAcR,GAAGQ,YAAY,CAACtB,YAAa,YAE3CK,QADQiB,YAAYC,YAAYvB,YAChB2B,IAAIP,KAE1Bf,QAAQG,QAAU,IAAMJ,OAAOC,QAAQI,OACvCJ,QAAQK,UAAY,IAAMP,QAAQE,QAAQM,QAAU,MAEpDW,YAAYG,WAAa,IAAMX,GAAGY,gCAShBP,MAAAA,YAChBL,SAAWb,gBACV,IAAIC,SAAQ,CAACC,QAASC,gBACnBkB,YAAcR,GAAGQ,YAAY,CAACtB,YAAa,aAE3CK,QADQiB,YAAYC,YAAYvB,YAChB4B,OAAOR,KAE7Bf,QAAQG,QAAU,IAAMJ,OAAOC,QAAQI,OACvCJ,QAAQK,UAAY,IAAMP,UAE1BmB,YAAYG,WAAa,IAAMX,GAAGY,gCAQhBP,gBAChBL,SAAWb,gBACV,IAAIC,SAAQ,CAACC,QAASC,gBACnBkB,YAAcR,GAAGQ,YAAY,CAACtB,YAAa,YAE3CK,QADQiB,YAAYC,YAAYvB,YAChB6B,aAEtBxB,QAAQG,QAAU,IAAMJ,OAAOC,QAAQI,OACvCJ,QAAQK,UAAY,IAAMP,QAAQE,QAAQM,QAAU,IAEpDW,YAAYG,WAAa,IAAMX,GAAGY"}